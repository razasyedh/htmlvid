#!/usr/bin/env python

# Convert dict back to Namespace????

"""htmlvid

A tool to create html5 snippets of videos.

Usage info is autogenerated by the argparse module and can be accessed by
running the program with the '-h' option.
"""

import sys
import os
import time
import configargparse
import subprocess


def video_file(string):
    """Check that our video file actually exists."""
    exists = os.path.isfile(string)
    if exists:
        return string
    else:
        msg = "File not found."
        raise configargparse.ArgumentTypeError(msg)

def time_stamp(string):
    """Prepend hours to our timestamp if the user omitted them."""
    semicolon_count = string.count(":")
    if semicolon_count == 1:
        string = "00:" + string

    return string

def crf(string):
    """Test that the quality number is within our range."""
    quality = int(string)
    if quality >= 0 and quality <= 63:
        return quality
    else:
        msg = "%r is out of the quality range. (0-63)" % string
        raise configargparse.ArgumentTypeError(msg)

def filesize(string):
    """Test if the filesize argument has a proper suffix."""
    number = string[:-1]
    suffix = string[-1].upper()
    if suffix == "K" or suffix == "M":
        return number + suffix
    else:
        msg = "%r does not include a K or M suffix." % string
        raise configargparse.ArgumentTypeError(msg)

def subtitle(string):
    """Test if our subtitle file exists."""
    if string == "0":
        return string
    else:
        exists = os.path.isfile(string)
        if exists:
            return string
        else:
            msg = "%r not found." % string
            raise configargparse.ArgumentTypeError(msg)

def get_args():
    """Obtain the arguments entered for our program on the command line."""
    # Define all of our arguments and their help messages
    parser = configargparse.ArgumentParser(add_help=False, prog="htmlvid",
                                           description="A tool to create html5"
                                                       " snippets of videos.",
                                           epilog="For additional help, see"
                                                  " man %(prog)s")

    group0 = parser.add_argument_group("Required Options")
    group0.add_argument("video", type=video_file,
                        help="The path to the video file.")

    group1 = parser.add_argument_group("General Options")
    group1.add_argument("-h", "--help", action="help",
                        help="Print this help message.")
    group1.add_argument("-o", "--output", metavar="name",
                        help="The output filename. If omitted, a unix"
                             " timestamp is used.")
#CONFIGGGGG
    group1.add_argument("-c", "--config", metavar="file", is_config_file=True,
                        help="The path to a custom config file.")
    group1.add_argument("-v", "--verbose", action="count",
                        help="Use once to show ffmpeg output and twice to make"
                             " %(prog)s verbose also.")
    group1.add_argument("-V", "--version", action="version",
                        version="%(prog)s 1.0.0", help="Print version number.")

    group2 = parser.add_argument_group("Time Options",)
    group2.add_argument("-s", "--start", metavar="time", type=time_stamp,
                        help="Time to start at in hh:mm:ss[.xxx] format.")
    group2.add_argument("-t", "--to", metavar="dur", type=time_stamp,
                        help="The duration in seconds and milliseconds. A"
                             " timestamp can also be used.")
    group2.add_argument("-D", "--duplicate", action="store_true",
                        help="Copy whole video. (Incompatible with -s/-t)")

    group3 = parser.add_argument_group("Format Options")
    group3.add_argument("-W", "--webm", action="store_true",
                        help="Create a webM. (Default)")
    group3.add_argument("-m", "--mp4", action="store_true",
                        help="Create an MP4 instead of webM. Quality works on"
                             " a different scale.")
    group3.add_argument("-S", "--sound", action="store_true",
                        help="Include sound.")

    group4 = parser.add_argument_group("Quality Options", "Use -l if you know"
                                       " size limit, else -q with -b")
    group4.add_argument("-q", "--quality", metavar="crf", type=crf,
                        help="Quality threshold. Lower is better. Defaults:"
                             " 10 for webM (4-63) and 23 for MP4 (0-51).")
    group4.add_argument("-b", "--bitrate", metavar="rate", type=filesize,
                        help="Bitrate to use. Must include K or M suffix."
                             " (Default: 750K)")
    group4.add_argument("-l", "--limit", metavar="size", type=filesize,
                        help="Set quality and bitrate to fit in the maximum"
                             " specified size. Must include K or M suffix."
                             " 2-pass.")
    group4.add_argument("-p", "--twopass", action="store_true",
                        help="Run two passes.")

    group5 = parser.add_argument_group("Filters")
    group5.add_argument("-w", "--width", metavar="num", type=int,
                        help="The width of the output file. Enter 0 for no"
                             " scaling. (Default: 640)")
    group5.add_argument("-e", "--embed", metavar="subs", type=subtitle,
                        help="Embed subtitles. Enter 0 to use internal subs.")
    group5.add_argument("-F", "--filters", metavar="filt",
                        help="Filters to pass to ffmpeg's -vf option"
                             " with commas separating them.")


    # Display a help message if the program is run without arguments
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()
    args = test_args(args)
    args = get_duration(args)

    return args

def error_out(short_arg, long_arg, message):
    """Print an error to stderr with the relevant arguments and exit."""

    sys.stderr.write("htmlvid: error: argument -%s/--%s: %s\n" % (short_arg,
                                                                  long_arg,
                                                                  message))
    sys.exit(1)

def test_args(args):
    """Test for missing, conflicting, or implying arguments."""
    if (args.start is None or args.to is None) and not args.duplicate:
        msg = "Start or end time missing."
        error_out("s/-t", "start/--to", msg)

    if (args.bitrate is None or args.quality is None) and args.limit is None:
        msg = "Bitrate or quality missing/"
        error_out("b/-q", "bitrate/--quality", msg)

    if args.mp4:
        if args.webm:
            msg = "Conflicting use with -W."
            error_out("m", "mp4", msg)

    if args.duplicate:
        if args.start is not None or args.to is not None:
            msg = "Conflicting use with -s/-t."
            error_out("D", "duplicate", msg)

    if args.limit is not None:
        if args.quality is not None or args.bitrate is not None:
            msg = "Conflicting use with -q/-b."
            error_out("l", "limit", msg)

        if not args.twopass:
            args.twopass = True

    if args.testrun and args.verbose is None:
        args.verbose = 2

    return args

def get_duration(args):
    """Get the duration in the case of a timestamp or duplication."""
    # If duration is a timestamp, convert to seconds
    if not args.duplicate:
        semicolons = args.to.count(":")
        if semicolons > 0:
            args.to = calculate_duration(args)

    # If copying with a size limit, get video duration
    if args.duplicate:
        if args.limit is not None:
            args.to = get_full_duration(FFPROBE_BIN, args.video)

    if float(args.to) > 300:
        msg = " Output video longer than 5 minutes. You should probably be"
        msg += " using ffmpeg directly at this point."
        sys.stderr.write("htmlvid: warning: %s\n" % msg)

    return args

def get_filters(args):
    """Chain together filters for the -vf portion of our command"""
    filterlist = [args.width, args.embed, args.filters]
    filter_cmd = ""

    for filters in filterlist:
        if filters is not None:
            filter_cmd = filter_cmd + ","

    # Remove trailing comma
    filter_cmd = filter_cmd[:-1]

    return filter_cmd

def timestamp_to_ms(timestamp):
    """Break up a timestamp and convert it to milliseconds."""
    # "hh" : "mm" : "ss.xxx"
    hms = timestamp.split(":")
    # Convert seconds and milliseconds to a list
    hms[2] = hms[2].split(".")
    # If there aren't any milliseconds
    if len(hms[2]) != 2:
        has_ms = False
    else:
        has_ms = True

    millisec = (int(hms[0]) * 3600 + int(hms[1]) * 60 + int(hms[2][0])) * 1000
    if has_ms:
        millisec += int(hms[2][1])

    return millisec

def calculate_duration(args):
    """Calculate the duration of our video if the -t arg is a timestamp"""
    # Calculate the difference between the two timestamps converted to ms
    beginning = timestamp_to_ms(args.start)
    end = timestamp_to_ms(args.to)

    difference_ms = end - beginning
    difference_s = float(difference_ms) / 1000

    return str(difference_s)

def calculate_bitrate(args):
    """Calculate the optimal bitrate for our size limit"""
    limit = args.limit
    size_limit = float(limit[:-1])
    # Convert megabyte to kilobyte
    if limit.endswith("M"):
        size_limit *= 1024

    vid_duration = float(args.to)

    new_limit = size_limit / vid_duration * 8
    new_limit = str(round(new_limit, 2)) + "K"
    return new_limit

def get_full_duration(ffprobe, video_path):
    cmd_list = cmd.split()
    """Run a command to get the duration of our input video."""
    cmd = "%s -i '%s'" % (ffprobe, video_path)
    cmd += " -loglevel error -show_entries format=duration"
    print "Command to get video duration: ", cmd

    metadata = subprocess.check_output(cmd_list)
    # [FORMAT]\nduration=s.xxxxx\n[/FORMAT]\n
    duration_line = metadata.splitlines()[1]
    # duration=s.xxxxx
    metadata_duration = duration_line.split("=")[1]

    return metadata_duration

def build_cmd(args):
    """Build our ffmpeg command from our arguments"""
    cmd = ""

    if os.name == "nt":
        ffmpeg_bin = "ffmpeg.exe"
        ffprobe_bin = "ffprobe.exe"
    else:
        ffmpeg_bin = "ffmpeg"
        ffprobe_bin = "ffprobe"
    cmd += ffmpeg_bin

    cmd += " -y"
    cmd += " -threads 0"
    cmd += " -hide_banner"

    # Set the proper verbosity for ffmpeg. Default only shows errors.
    if args.verbose is None:
        verbosity = "error"
    else:
        verbosity = "info"
    cmd += " -loglevel %s" % verbosity

    seek_cmd = " -ss %s" % args.start
    input_cmd = " -i '%s'" % args.video
    if args.embed is None:
        # fast seek if not embedding subs
        cmd = cmd + seek_cmd + input_cmd
    else:
        cmd = cmd + input_cmd + seek_cmd

    # If copying, get video duration
    if args.duplicate:
        args.to = get_full_duration(ffprobe_bin, args.video)

    # If duration is a timestamp, convert to a duration
    semicolons = args.to.count(":")
    if semicolons > 0:
        args.to = calculate_duration(args)
    cmd += " -t %s" % args.to

    if args.mp4:
        codec = "libx264"
        extension = ".mp4"
    else:
        codec = "libvpx"
        extension = ".webm"
    cmd += " -c:v %s" % codec

    if args.limit is None:
        cmd += " -crf %s" % args.quality
        cmd += " -b:v %s" % args.bitrate
    else:
        bitrate = calculate_bitrate(args)
        # cmd += " -crf 0"
        cmd += " -b:v %s" % bitrate

    filters = get_filters(args)
    if filters != "":
        cmd += " -vf %s" % filters

    # Exclude sound
    if not args.sound:
        cmd += " -an"

    # Output File
    if args.output is None:
        filename = str(int(time.time())) + extension
    else:
        filename = args.output
    cmd += " '%s'" % filename

    print cmd
    return cmd

def run_cmd(cmd, passes):
    """Takes the ffmpeg command list and runs it"""
    # Split the quoted filenames first, then concat the rest of the list
    cmds = cmd.split("'")
    cmd_list = cmds[0].split() + [cmds[1]] + cmds[2].split() + [cmds[3]]

    exit_code = subprocess.call(cmd_list)

    if exit_code != 0:
        print "ffmpeg exited with a nonzero error code(%d)" % exit_code
        exit(1)

def main():
    """Get options from config file and the command line. Then use them to
    create and execute our ffmpeg command.
    """
    arguments = get_args()

    # for key in var(arguments):
    #     print key, ":", arguments[key]
    # print "\n\n"

    command = build_cmd(arguments)

    if arguments.twopass:
        passes = 2
    else:
        passes = 1

    # run_cmd(command, passes)
    sys.exit(0)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        sys.stderr.write("User sent keyboard interrupt. Exiting...")
        exit(1)

# prepend the zeroes in timestamp

# try variable bitrate only for -l (-b:v) and leave out the -crf
# B:V (max bitrate for crf) might have no effect for mp4's. test it out, might
#  have to use presets

# sub-commands to concat/cut/other??

# detect what flags ffmpeg was compiled with to remove unused options
# (ffmpeg -hide_banner -buildconf)


# https://trac.ffmpeg.org/wiki/Encode/VP8
# https://trac.ffmpeg.org/wiki/Encode/H.264
# constant quality mode is reccomended for libpvx
# -q uses Variable bitrate, -l uses constant quality
# This version of ffmpeg has nonfree parts compiled in. Therefore it is not
# legally redistributable.
