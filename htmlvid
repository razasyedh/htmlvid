#!/usr/bin/env python

"""htmlvid

An FFmpeg wrapper for creating HTML5 snippets of videos.

Usage info is autogenerated by the configargparse module and can be accessed
by running the program with the '-h' option.
"""

import configargparse
import subprocess
import sys
import os
import shutil
import shlex
import tempfile
import time

def video_file(string):
    """Test that our video file exists."""
    exists = os.path.isfile(string)
    if exists:
        return string
    else:
        msg = "File not found."
        raise configargparse.ArgumentTypeError(msg)

def time_stamp(string):
    """Test that the timestamp given is proper and prepend zeroes to our
    timestamp if the user omitted them to prepare it for calculate_duration().
    """
    leading_digits_count = len(string.split(":")[0])
    if leading_digits_count == 1:
        string = "0" + string

    semicolon_count = string.count(":")
    if semicolon_count == 0:
        if len(string) > 2:
            msg = "%s is not a proper timestamp." % string
            raise configargparse.ArgumentTypeError(msg)

        string = "00:00:" + string
    elif semicolon_count == 1:
        string = "00:" + string

    return string

def crf(string):
    """Test that the quality number is within the proper range."""
    quality = int(string)
    if quality >= 0 and quality <= 63:
        return quality
    else:
        msg = "%s is out of the quality range. (0-63)" % string
        raise configargparse.ArgumentTypeError(msg)

def filesize(string):
    """Test that the filesize argument has a proper suffix."""
    number = string[:-1]
    suffix = string[-1].upper()
    if suffix == "K" or suffix == "M":
        return number + suffix
    else:
        msg = "%s does not include a K or M suffix." % string
        raise configargparse.ArgumentTypeError(msg)

def subtitle(string):
    """Test if our subtitle file exists."""
    if string == "0":
        return string
    else:
        exists = os.path.isfile(string)
        if exists:
            return string
        else:
            msg = "%r not found." % string
            raise configargparse.ArgumentTypeError(msg)

def get_args():
    """Obtain the arguments entered for our program on the command line."""
    # Define all of our arguments and their help messages
    description = ("htmlvid - A tool for creating HTML5 snippets of videos"
                   " using FFmpeg.")
    epilog = ("Example: `htmlvid -s 2:10 -t 5 video.mkv` creates a 5 second"
              " snippet of video.mkv starting at 2 minutes and 10 seconds."
              "Author: Syed Raza <github.com/razasyedh>")
    parser = configargparse.ArgumentParser(add_help=False, prog="htmlvid",
                                           default_config_files=["~/.htmlvid"],
                                           add_config_file_help=False,
                                           description=description,
                                           epilog=epilog)

    group0 = parser.add_argument_group("Required Options")
    group0.add_argument("video", type=video_file,
                        help="The path to the video file.")

    group1 = parser.add_argument_group("General Options")
    group1.add_argument("-h", "--help", action="help",
                        help="Print this help message.")
    group1.add_argument("-o", "--output", metavar="name",
                        help="The output filename/filepath. If omitted, a Unix"
                             " timestamp is used.")
    group1.add_argument("-c", "--config", metavar="file", is_config_file=True,
                        help="The path to a custom config file. The default"
                             " config file is located at ~/.htmlvid.")
    group1.add_argument("-v", "--verbose", action="count",
                        help="Use once to make %(prog)s verbose, twice to show"
                             " FFmpeg output, and three times for both.")
    group1.add_argument("-V", "--version", action="version",
                        version="%(prog)s 1.0.0", help="Print version number.")

    group2 = parser.add_argument_group("Time Options",)
    group2.add_argument("-s", "--start", metavar="time", type=time_stamp,
                        help="Time to start at in hh:mm:ss[.xxx] format.")
    group2.add_argument("-t", "--to", metavar="dur", type=time_stamp,
                        help="The duration in seconds and milliseconds. A"
                             " timestamp can also be used.")
    group2.add_argument("-D", "--duplicate", action="store_true",
                        help="Copy whole video. (Incompatible with -s/-t)")

    group3 = parser.add_argument_group("Format Options")
    group3.add_argument("-W", "--webm", action="store_true",
                        help="Create a webM. (Default)")
    group3.add_argument("-m", "--mp4", action="store_true",
                        help="Create an MP4 instead of webM. Quality works on"
                             " a different scale.")
    group3.add_argument("-S", "--sound", action="store_true",
                        help="Include sound.")
    group3.add_argument("-M", "--metadata", metavar="title",
                        help="Set the title of the video in the metadata. If"
                             " omitted, the original filename is used.")

    group4 = parser.add_argument_group("Quality Options", "Use -l if you know"
                                       " the size limit, else -q with -b.")
    group4.add_argument("-q", "--quality", metavar="crf", type=crf,
                        help="Quality threshold. Lower is better. Defaults:"
                             " 10 for WebM (4-63) and 23 for MP4 (0-51).")
    group4.add_argument("-b", "--bitrate", metavar="rate", type=filesize,
                        help="Maximum bitrate to use for WebM's. Must include K"
                             " or M suffix. Default: 750K.")
    group4.add_argument("-l", "--limit", metavar="size", type=filesize,
                        help="Set quality and bitrate to fit in the maximum"
                             " specified size. Must include K or M suffix."
                             " 2-pass.")
    group4.add_argument("-p", "--twopass", action="store_true",
                        help="Run two passes.")

    group5 = parser.add_argument_group("Filters")
    group5.add_argument("-w", "--width", metavar="num", type=int,
                        help="The width of the output file. Enter 0 for no"
                             " scaling.")
    group5.add_argument("-e", "--embed", metavar="subs", type=subtitle,
                        help="Embed a subtitles file. Enter 0 to use internal"
                             " subs.")

    group6 = parser.add_argument_group("Misc")
    group6.add_argument("-F", "--filters", metavar="filt",
                        help="Filters to pass to FFmpeg's '-vf' option"
                             " with commas separating them.")
    group6.add_argument("-T", "--testrun", action="store_true",
                        help="Don't actually run and instead display the"
                             " FFmpeg command that would have been executed.")


    # Display a help message and exit if the program is run without arguments
    if len(sys.argv) == 1:
        parser.print_help()

    args = parser.parse_args()
    args = test_args(args)
    args = get_duration(args)

    return args


def error_out(short_arg, long_arg, message):
    """Print an error to stderr with the relevant arguments and exit."""

    error = "argument -%s/--%s: %s\n" % (short_arg, long_arg, message)
    sys.stderr.write("htmlvid: error: %s" % error)
    sys.exit(1)

def test_args(args):
    """Test for missing, conflicting, or implying arguments."""
    if (args.start is None or args.to is None) and not args.duplicate:
        msg = "Start or end time missing."
        error_out("s/-t", "start/--to", msg)

    if (args.bitrate is None or args.quality is None) and args.limit is None:
        msg = "Bitrate or quality missing/"
        error_out("b/-q", "bitrate/--quality", msg)

    if args.mp4:
        if args.webm:
            msg = "Conflicting use with -W."
            error_out("m", "mp4", msg)

    if args.duplicate:
        if args.start is not None or args.to is not None:
            msg = "Conflicting use with -s/-t."
            error_out("D", "duplicate", msg)

    if args.limit is not None:
        if args.quality is not None or args.bitrate is not None:
            msg = "Conflicting use with -q/-b."
            error_out("l", "limit", msg)

        if not args.twopass:
            args.twopass = True

    if args.testrun and args.verbose is None:
        args.verbose = 2

    return args

def get_duration(args):
    """Get the duration in the case of a timestamp or duplication."""
    # If duration is a timestamp, convert to seconds
    if not args.duplicate:
        semicolons = args.to.count(":")
        if semicolons > 0:
            args.to = calculate_duration(args)

    # If copying with a size limit, get video duration
    if args.duplicate:
        if args.limit is not None:
            args.to = get_full_duration(FFPROBE_BIN, args.video)


    return args

def get_filters(args):
    """Chain filters together to make the -vf part of our FFmpeg command."""
    # Create our width filter if we didn't enter 0
    if args.width is None or args.width == 0:
        width_filter = None
    else:
        width_filter = "scale=%s:-1" % args.width

    filterlist = [width_filter, args.embed, args.filters]
    filter_cmd = ""

    for filters in filterlist:
        if filters is not None:
            filter_cmd = filter_cmd + filters + ","

    # Remove trailing comma
    filter_cmd = filter_cmd[:-1]

    return filter_cmd

def timestamp_to_ms(timestamp):
    """Break up a timestamp and convert it to milliseconds."""
    # "hh" : "mm" : "ss.xxx"
    hms = timestamp.split(":")
    # Split seconds and milliseconds into sublist
    hms[2] = hms[2].split(".")
    # If there aren't any milliseconds
    if len(hms[2]) != 2:
        has_ms = False
    else:
        has_ms = True

    millisec = (int(hms[0]) * 3600 + int(hms[1]) * 60 + int(hms[2][0])) * 1000
    if has_ms:
        millisec += int(hms[2][1])

    return millisec

def calculate_duration(args):
    """Calculate the duration of our video if the -t arg is a timestamp."""
    # Calculate the difference between the two timestamps converted to ms
    beginning = timestamp_to_ms(args.start)
    end = timestamp_to_ms(args.to)

    difference_ms = end - beginning
    difference_s = float(difference_ms) / 1000

    return str(difference_s)

def calculate_bitrate(limit, duration):
    """Calculate the optimal bitrate for our size limit."""
    size_limit = float(limit[:-1])
    # Convert megabyte to kilobyte
    if limit.endswith("M"):
        size_limit *= 1024

    vid_duration = float(duration)

    new_limit = size_limit / vid_duration * 8
    new_limit = str(round(new_limit, 2)) + "K"
    return new_limit

def get_full_duration(ffprobe, video_path):
    """Run a command to get the duration of our input video."""
    cmd = "%s -i '%s'" % (ffprobe, video_path)
    cmd += " -loglevel error -show_entries format=duration"
    cmd_list = shlex.split(cmd)

    # Expected input: "[FORMAT]\nduration=s.xxxxx\n[/FORMAT]\n"
    metadata = subprocess.check_output(cmd_list)
    # Expected output: "duration=s.xxxxx"
    duration_line = metadata.splitlines()[1]
    # Expected output: "s.xxx"
    metadata_duration = duration_line.split("=")[1][:-2]

    return metadata_duration

def build_cmd(args):
    """Build our FFmpeg command from our arguments.

    Note: Uses string concat instead of list append because: 1) It's more
    readable and apparent, and 2) It's not slow, at least on my machine, so
    no need for premature optimization.
    """

    cmd = FFMPEG_BIN + " -y -vstats_file log.txt"

    # Set the proper verbosity for ffmpeg. Default only shows errors.
    if args.verbose is None:
        verbosity = "error"
    else:
        verbosity = "info"
    cmd += " -loglevel %s" % verbosity

    if not args.duplicate:
        seek_cmd = " -ss %s" % args.start
    else:
        seek_cmd = ""
    input_cmd = " -i '%s'" % args.video
    if args.embed is None:
        # Fast seek if not embedding subs
        cmd = cmd + seek_cmd + input_cmd
    else:
        # Slow seek
        cmd = cmd + input_cmd + seek_cmd

    if not args.duplicate:
        cmd += " -t %s" % args.to

    if args.mp4:
        codec = "libx264"
        extension = ".mp4"
    else:
        codec = "libvpx"
        extension = ".webm"
    cmd += " -c:v %s" % codec

    if args.limit is None:
        cmd += " -crf %s" % args.quality
        cmd += " -b:v %s" % args.bitrate
    else:
        bitrate = calculate_bitrate(args.limit, args.to)
        cmd += " -b:v %s" % bitrate

    filters = get_filters(args)
    if filters != "":
        cmd += " -vf '%s'" % filters

    # Exclude sound
    if not args.sound:
        cmd += " -an"

    if args.twopass:
        cmd += " -pass 1"

    if args.metadata is None:
        meta_filename = os.path.basename(args.video)
        meta_filename = meta_filename[:-4]
    else:
        meta_filename = args.metadata
    cmd += " -metadata title='%s'" % meta_filename

    # Output File
    if args.output is None:
        filename = str(int(time.time())) + extension
    else:
        filename = args.output
    cmd += " '%s'" % filename

    return cmd

def get_temp_dir():
    """Create a temporary directory to store our video and ffmpeg logs."""
    temp_folder = tempfile.gettempdir()
    temp_dir = temp_folder + os.sep + "htmlvid"
    if not os.path.exists(temp_dir):
        os.makedirs(temp_dir)

    return temp_dir

def run_cmd(cmd):
    """Takes the ffmpeg command and runs it."""

    cmd_list = shlex.split(cmd)

    # Set up the folder and file paths
    working_dir = os.getcwd()
    temp_dir = get_temp_dir()
    filename = cmd_list[-1]
    output_dir = os.path.dirname(filename)
    output_file = os.path.basename(filename)
    filepath = temp_dir + os.sep + output_file

    # Find out if we're in the first pass of a twopass run
    is_not_first_pass = False
    if cmd.find("-pass 1") < 0:
        is_not_first_pass = True

    print temp_dir
    print filename


    # Run the FFmpeg command in the temp directory
    ffmpeg_process = subprocess.Popen(cmd_list, cwd=temp_dir)

    # Wait until FFmpeg exits and interpret the exit code
    exit_code = None
    while exit_code is None:
        exit_code = subprocess.Popen.poll(ffmpeg_process)
    if exit_code != 0:
        print "FFmpeg exited with a nonzero error code(%d)" % exit_code
        exit(1)

    # Move the video to our destination
    if is_not_first_pass and output_dir == "":
        shutil.move(filepath, working_dir)

def main():
    """Get options from the config file and the command line. Then use them to
    create and execute the FFmpeg command.
    """
    args = get_args()
    command = build_cmd(args)

    # Run the FFmpeg command if we're not testing and run twice if two passes
    if not args.testrun:
        run_cmd(command)
        if args.twopass:
            command2 = command.replace("-pass 1", "-pass 2")
            print "Running pass 2"
            run_cmd(command2)

    sys.exit(0)

if __name__ == "__main__":
    if os.name == "nt": # Windows
        FFMPEG_BIN = "ffmpeg.exe"
        FFPROBE_BIN = "ffprobe.exe"
    else: # Unix
        FFMPEG_BIN = "ffmpeg"
        FFPROBE_BIN = "ffprobe"

    try:
        main()
    except KeyboardInterrupt:
        sys.stderr.write("\nUser sent keyboard interrupt. Exiting...\n")
        exit(1)
