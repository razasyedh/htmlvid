#!/usr/bin/env python

"""htmlvid

An FFmpeg wrapper for creating HTML5 snippets of videos.

Usage info is autogenerated by the configargparse module and can be accessed
by running the program with the '-h' option.
"""

import configargparse
import subprocess
import sys
import os
import shutil
import shlex
import tempfile
import time

def video_file(string):
    """Test that our video file exists."""
    exists = os.path.isfile(string)
    if exists:
        return string
    else:
        msg = "File not found."
        raise configargparse.ArgumentTypeError(msg)

def time_stamp(string):
    """Test that the timestamp given is proper and prepend zeroes to our
    timestamp if the user omitted them to prepare it for calculate_duration().
    """
    leading_digits_count = len(string.split(":")[0])
    if leading_digits_count == 1:
        string = "0" + string

    semicolon_count = string.count(":")
    if semicolon_count == 0:
        if len(string) > 2:
            msg = "%s is not a proper timestamp." % string
            raise configargparse.ArgumentTypeError(msg)

        string = "00:00:" + string
    elif semicolon_count == 1:
        string = "00:" + string

    return string

def duration(string):
    """Test if the input is a timestamp or a duration.

    If it is a timestamp, pass it to time_stamp() to properly format it, or
    else just return the duration.
    """
    semicolon_count = string.count(":")
    if semicolon_count > 0:
        string = time_stamp(string)

    return string

def crf(string):
    """Test that the quality number is within the proper range."""
    quality = int(string)
    if quality >= 0 and quality <= 63:
        return quality
    else:
        msg = "%s is out of the quality range. (0-63)" % string
        raise configargparse.ArgumentTypeError(msg)

def filesize(string):
    """Test that the filesize argument has a proper suffix."""
    number = string[:-1]
    suffix = string[-1].upper()
    if suffix == "K" or suffix == "M":
        return number + suffix
    else:
        msg = "%s does not include a K or M suffix." % string
        raise configargparse.ArgumentTypeError(msg)

def ffmpeg_options(string):
    """Test that every option has an argument and is allowed."""
    string = string.replace("\\", "")

    words = string.split()
    if len(words) % 2 != 0:
        msg = "Every option doesn't have exactly one argument."
        raise configargparse.ArgumentTypeError(msg)

    # Check for options already used internally
    option_list = []
    for word in string.split(" "):
        if word[0] == "-":
            option_list.append(word)
    blacklist = ["-ss", "-t", "-loglevel", "-threads", "-an", "-sn", "-vf"]
    matches = set(option_list).intersection(blacklist)
    if matches:
        msg = "Option(s) %s used internally by htmlvid." % list(matches)
        raise configargparse.ArgumentTypeError(msg)

    return string

def subtitle(string):
    """Test that the specified subtitle file exists."""
    exists = os.path.isfile(string)
    if exists or string == "0":
        return string
    else:
        msg = "%s not found." % string
        raise configargparse.ArgumentTypeError(msg)

def get_args():
    """Obtain the arguments entered for our program on the command line."""
    # Define all of our arguments and their help messages
    description = ("htmlvid - A tool for creating HTML5 snippets of videos"
                   " using FFmpeg.")
    epilog = ("Example: `htmlvid -s 2:10 -t 5 video.mkv` creates a 5 second"
              " snippet of video.mkv starting at 2 minutes and 10 seconds."
              "Author: Syed Raza <github.com/razasyedh>")
    parser = configargparse.ArgumentParser(add_help=False, prog="htmlvid",
                                           default_config_files=["~/.htmlvid"],
                                           add_config_file_help=False,
                                           description=description,
                                           epilog=epilog)

    group0 = parser.add_argument_group("Required Options")
    group0.add_argument("video", type=video_file,
                        help="The path to the video file.")

    group1 = parser.add_argument_group("General Options")
    group1.add_argument("-h", "--help", action="help",
                        help="Print this help message.")
    group1.add_argument("-o", "--output", metavar="name",
                        help="The output filename/filepath. If omitted, a Unix"
                             " timestamp is used.")
    group1.add_argument("-c", "--config", metavar="file", is_config_file=True,
                        help="The path to a custom config file. The default"
                             " config file is located at ~/.htmlvid.")
    group1.add_argument("-v", "--verbose", action="count",
                        help="Use once to make %(prog)s verbose, twice to show"
                             " FFmpeg output, and three times for both.")
    group1.add_argument("-V", "--version", action="version",
                        version="%(prog)s 1.0.0", help="Print version number.")

    group2 = parser.add_argument_group("Time Options",)
    group2.add_argument("-s", "--start", metavar="time", type=time_stamp,
                        help="Time to start at in hh:mm:ss[.xxx] format.")
    group2.add_argument("-t", "--to", metavar="dur", type=duration,
                        help="The duration in seconds and milliseconds. A"
                             " timestamp can also be used.")
    group2.add_argument("-D", "--duplicate", action="store_true",
                        help="Copy whole video. (Incompatible with -s/-t)")

    group3 = parser.add_argument_group("Format Options")
    group3.add_argument("-f", "--format", choices=["webm", "mp4"],
                        default="webm",
                        help="Whether to create a WebM or MP4. Quality works"
                             " on a different scale for each. (Default: webm)")
    group3.add_argument("-S", "--sound", action="store_true",
                        help="Include sound.")
    group3.add_argument("-M", "--metadata", metavar="title",
                        help="Set the title of the video in the metadata. If"
                             " omitted, the original filename is used.")

    group4 = parser.add_argument_group("Quality Options", "Use -l if you know"
                                       " the size limit, else -q with -b.")
    group4.add_argument("-q", "--quality", metavar="crf", type=crf,
                        help="Quality threshold. Lower is better. Defaults:"
                             " 10 for WebM (4-63) and 23 for MP4 (0-51).")
    group4.add_argument("-b", "--bitrate", metavar="rate", type=filesize,
                        help="Maximum bitrate to use for WebM's. Must include K"
                             " or M suffix. Default: 750K.")
    group4.add_argument("-l", "--limit", metavar="size", type=filesize,
                        help="Set quality and bitrate to fit in the maximum"
                             " specified size. Must include K or M suffix."
                             " 2-pass.")
    group4.add_argument("-p", "--twopass", action="store_true",
                        help="Run two passes.")

    group5 = parser.add_argument_group("Filters")
    group5.add_argument("-w", "--width", metavar="num", type=int,
                        help="The width of the output file. Enter 0 for no"
                             " scaling.")
    group5.add_argument("-e", "--embed", metavar="subs", type=subtitle,
                        help="Embed a subtitles file. Enter 0 to use internal"
                             " subs.")

    group6 = parser.add_argument_group("Misc")
    group6.add_argument("-O", "--options", metavar="opts", type=ffmpeg_options,
                        help="Options to pass directly to FFmpeg. (Escape any"
                             " dashes and quote spaces. ie: \\-foo 'bar baz')")
    group6.add_argument("-F", "--filters", metavar="filt",
                        help="Filters to pass to FFmpeg's '-vf' option"
                             " with commas separating them.")
    group6.add_argument("-T", "--testrun", action="store_true",
                        help="Don't actually run and instead display the"
                             " FFmpeg command that would have been executed.")


    # Display a help message and exit if the program is run without arguments
    if len(sys.argv) == 1:
        parser.print_help()

    args = parser.parse_args()
    test_conflicts(args)
    set_implied(args)

    verbose_print("\n%s" % parser.format_values(), args.verbose)
    verbose_print_args(args)

    return args


def error_out(short_arg, long_arg, message):
    """Print an error to stderr with the relevant arguments and exit."""

    error = "argument -%s/--%s: %s\n" % (short_arg, long_arg, message)
    sys.stderr.write("htmlvid: error: %s" % error)
    sys.exit(1)

def test_conflicts(args):
    """Test that arguments aren't missing or conflicting with each other."""
    if args.start is None and not args.duplicate:
        msg = "Start time missing."
        error_out("s", "start", msg)

    if args.to is None and not args.duplicate:
        msg = "End time missing."
        error_out("t", "to", msg)

    if args.duplicate:
        if args.start is not None or args.to is not None:
            msg = "Conflicting use with -s/-t."
            error_out("D", "duplicate", msg)

    if args.limit is not None:
        if args.quality is not None or args.bitrate is not None:
            msg = "Conflicting use with -q/-b."
            error_out("l", "limit", msg)

    return

def set_implied(args):
    """If an option used implies a value or another option, set it."""
    if args.quality is None and args.limit is None:
        if args.format == "webm":
            args.quality = 10
        else:
            args.quality = 23

    if args.format == "webm":
        if args.bitrate is None and args.limit is None:
            args.bitrate = "750K"

    if args.limit is not None:
        args.twopass = True

    if args.testrun and (args.verbose is None or args.verbose == 2):
        args.verbose = 1

    if args.metadata is None:
        # Get filename without an extension
        fname = os.path.basename(args.video)
        args.metadata = os.path.splitext(fname)[0]

    # If copying, get full video duration
    if args.duplicate:
        args.to = get_full_duration(args.video)
    else:
        # If duration is a timestamp, convert to seconds
        if args.to.count(":") > 0:
            args.to = calculate_duration(args.start, args.to)

    # If no filename specified, generate one
    if args.output is None:
        unix_time = str(int(time.time()))
        start_time = args.start.replace(":", "_")
        time_info = "%s+%ss" % (start_time, args.to)
        args.output = "%s_%s.%s" % (unix_time, time_info, args.format)
    # If filename has no extension, append
    else:
        if args.output[-4:] not in ["webm", ".mp4"]:
            args.output += ".%s" % args.format

    return

def verbose_print_args(args):
    """Print the argument Namespace as a dict, showing the keys and values."""
    if args.verbose in [1, 3] and not args.testrun:
        print "Option : Value"
        print "---"

        argsdict = vars(args)
        for key in argsdict:
            print key, ":", argsdict[key]
        print

    return

def verbose_print(message, verbose):
    """Print messages that are passed if the verbose flag is set."""
    if verbose in [1, 3]:
        print message

    return

def verbose_print_cmd(cmd, verbose):
    """Print our ffmpeg command."""
    # Omit flag to overwrite file and flag for a log file
    message = cmd.replace(" -y -vstats_file log.txt", "")

    if verbose in [1, 3]:
        print message, "\n"

    return

def get_filters(args):
    """Chain filters together to make the -vf part of our FFmpeg command."""
    # Create our width filter if we didn't enter 0
    if args.width is None or args.width == 0:
        width_filter = None
    else:
        if args.format == "webm":
            # min() makes sure we don't scale larger than our video size
            width_filter = "scale=min(%s\\,iw):-1" % args.width
        else:
            # For mp4 we have to make sure our new dimensions are even numbers
            width_filter = "scale=min(%s\\,iw):trunc(ow/a/2)*2" % args.width

    # Generate our filtergraph
    filter_list = [width_filter, args.embed, args.filters]
    filter_graph = ""

    for filters in filter_list:
        if filters is not None:
            filter_graph = filter_graph + filters + ","

    # Remove trailing comma
    filter_graph = filter_graph[:-1]

    return filter_graph

def timestamp_to_ms(timestamp):
    """Break up a timestamp and convert it to milliseconds."""
    # "hh" : "mm" : "ss.xxx"
    hms = timestamp.split(":")
    # Split seconds and milliseconds into sublist
    hms[2] = hms[2].split(".")
    # If there aren't any milliseconds
    if len(hms[2]) != 2:
        has_ms = False
    else:
        has_ms = True

    millisec = (int(hms[0]) * 3600 + int(hms[1]) * 60 + int(hms[2][0])) * 1000
    if has_ms:
        millisec += int(hms[2][1])

    return millisec

def calculate_duration(start, end):
    """Calculate the difference between two timestamps converted to ms."""
    start_ms = timestamp_to_ms(start)
    end_ms = timestamp_to_ms(end)

    difference_ms = float(end_ms - start_ms)
    difference_s = str(difference_ms / 1000)

    # Remove trailing decimal zero
    if difference_s.split(".")[1] == "0":
        difference_s = difference_s[:-2]

    return difference_s

def calculate_bitrate(limit, duration):
    """Calculate the optimal bitrate for our size limit."""
    vid_duration = float(duration)
    size_limit = float(limit[:-1])
    # Convert megabyte to kilobyte
    if limit.endswith("M"):
        size_limit *= 1024

    bitrate = size_limit / vid_duration * 8
    bitrate = str(round(bitrate, 2)) + "K"
    return bitrate

def get_full_duration(video_path):
    """Run a command to get the duration of our input video."""
    cmd = "%s -i '%s'" % (FFPROBE_BIN, video_path)
    cmd += " -loglevel error -show_entries format=duration"
    cmd_list = shlex.split(cmd)

    # Expected input: "[FORMAT]\nduration=s.xxxxx\n[/FORMAT]\n"
    metadata = subprocess.check_output(cmd_list)
    # Expected output: "duration=s.xxxxx"
    duration_line = metadata.splitlines()[1]
    # Expected output: "s.xxx"
    metadata_duration = duration_line.split("=")[1][:-2]

    return metadata_duration

def build_cmd(args):
    """Build our FFmpeg command from our arguments.

    Note: Uses string concat instead of list append because: 1) It's more
    readable and apparent, and 2) It's not slow, at least on my machine, so
    no need for premature optimization.
    """

    cmd = FFMPEG_BIN + " -y -vstats_file log.txt"

    # Set the proper verbosity for FFmpeg
    if args.verbose is None or args.verbose == 1:
        verbosity = "error"
    else:
        verbosity = "info"
    cmd += " -loglevel %s" % verbosity

    if USE_ALL_THREADS:
        cmd += " -threads 0"

    if not args.duplicate:
        seek_cmd = " -ss %s" % args.start
    else:
        seek_cmd = ""
    input_cmd = " -i '%s'" % args.video
    if args.embed is None:
        # Fast seek if not embedding subs
        cmd = cmd + seek_cmd + input_cmd
    else:
        # Slow seek
        cmd = cmd + input_cmd + seek_cmd

    if not args.duplicate:
        cmd += " -t %s" % args.to

    if args.limit is None:
        # Constant quality mode
        cmd += " -crf %s" % args.quality
        if args.format == "webm":
            cmd += " -b:v %s" % args.bitrate
        else:
            cmd += " -preset %s" % MP4_PRESET
    else:
        bitrate = calculate_bitrate(args.limit, args.to)
        # Constant bitrate mode
        cmd += " -b:v %s -minrate %s -maxrate %s" % (bitrate, bitrate, bitrate)

    filters = get_filters(args)
    if filters != "":
        cmd += " -vf '%s'" % filters

    if args.sound:
        # Enable experimental encoders and downmux to two channels
        cmd += " -strict experimental -ac 2"
    else:
        cmd += " -an"

    # Disable subtitles
    cmd += " -sn"

    if args.twopass:
        cmd += " -pass 1"

    cmd += " -metadata title='%s'" % args.metadata

    if args.options is not None:
        cmd += " %s" % args.options

    # Output File
    cmd += " '%s'" % args.output

    verbose_print_cmd(cmd, args.verbose)

    return cmd

def print_progress(log_path, duration):
    """Show the progress of our FFmpeg command."""

    # Read the logfile and get the last line
    try:
        log_file = open(log_path, "r")
    except IOError:
        return

    lines = log_file.readlines()

    try:
        last_line = lines[-2]
    except IndexError:
        return

    log_file.close()

    # Find out the current time FFmpeg is at
    # Expected input:
    # "[...] s_size=      nnnkB time= s.xxx br=  nnnn.nkbits/s [...]"
    time_beginning = last_line.find("time=")
    time_end = last_line.find("br=")
    current_time = last_line[time_beginning+6:time_end]

    duration = float(duration)
    current_time = float(current_time)
    percent = current_time / duration * 100

    print "\rProgress: %.0f%% (%.3f/%.3fs)" % (percent, current_time, duration),
    sys.stdout.flush() # Needed to show the output

    return

def run_cmd(command, duration, is_two_pass, verbosity):
    """Take the FFmpeg command and run it."""

    cmd_list = shlex.split(command)

    # Set up the folder and file paths
    temp_dir = os.path.join(tempfile.gettempdir(), "htmlvid")
    log_path = os.path.join(temp_dir, "log.txt")
    filename = cmd_list[-1]
    output_dir = os.path.dirname(filename)
    output_file = os.path.basename(filename)
    filepath = os.path.join(temp_dir, output_file)

    # Figure out which pass we are on
    is_first_pass = False
    if command.find("-pass 1") != -1:
        is_first_pass = True

    # Delete and create temporary directory
    if not is_two_pass or is_first_pass:
        try:
            shutil.rmtree(temp_dir)
        except OSError:
            pass
        os.makedirs(temp_dir)

    # Remove log file after first run so it doesn't mess up the progress
    if is_two_pass and not is_first_pass:
        os.remove(log_path)

    # Print the temp folder and filename if we're verbose
    if not is_two_pass or is_first_pass:
        msg = "Platform: %s" % sys.platform
        verbose_print(msg, verbosity)
        msg = "Temp Folder: %s" % temp_dir
        verbose_print(msg, verbosity)
        msg = "Filename: %s\n" % filename
        verbose_print(msg, verbosity)

    # Run the FFmpeg command in the temp directory
    ffmpeg_process = subprocess.Popen(cmd_list, cwd=temp_dir)

    # Wait until FFmpeg exits and interpret the exit code
    exit_code = None
    while exit_code is None:
        exit_code = subprocess.Popen.poll(ffmpeg_process)

        if verbosity in [None, 1] and not is_first_pass:
            print_progress(log_path, duration)

        time.sleep(1)
    if exit_code != 0:
        print "FFmpeg exited with a nonzero error code(%d)" % exit_code
        exit(1)

    if verbosity != 2 and not is_first_pass:
        print "\rProgress: Finished                    "

    # Move the video to the working directory if nothing was specified with -o
    if not is_first_pass and output_dir == "":
        shutil.move(filepath, os.getcwd())

def main():
    """Get options from the config file and the command line. Then use them to
    create and execute the FFmpeg command.
    """
    args = get_args()
    command = build_cmd(args)

    # Run the FFmpeg command if we're not testing and run twice if two passes
    if not args.testrun:
        if args.twopass:
            print "Running Pass 1"

        run_cmd(command, args.to, args.twopass, args.verbose)

        if args.twopass:
            command2 = command.replace("-pass 1", "-pass 2")
            print "Running pass 2"

            run_cmd(command2, args.to, args.twopass, args.verbose)

    sys.exit(0)

if __name__ == "__main__":
    if os.name == "nt": # Windows
        FFMPEG_BIN = "ffmpeg.exe"
        FFPROBE_BIN = "ffprobe.exe"
    else: # Unix
        FFMPEG_BIN = "ffmpeg"
        FFPROBE_BIN = "ffprobe"
    USE_ALL_THREADS = True # Whether to multithread or not
    MP4_PRESET = "slower" # libx264 default: medium

    try:
        main()
    except KeyboardInterrupt:
        sys.stderr.write("\nUser sent keyboard interrupt. Exiting...\n")
        exit(1)
