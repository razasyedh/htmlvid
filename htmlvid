#!/usr/bin/env python

# Convert dict back to Namespace????

"""htmlgif

A tool to create html5 snippets of videos.

Usage info is autogenerated by the argparse module and can be accessed by
running the program with the '-h' option.
"""

import sys
import os
import time
import configargparse
import subprocess

def error_out(short_arg, long_arg, message):
    """Print an error to stderr and exit. Needed because configargparse
    doesn't support ArgumentTypeError.
    """

    sys.stderr.write("error: argument -%s/--%s: %s\n" % (short_arg,
                                                         long_arg, message))
    sys.exit(1)

def time_stamp(string):
    """Test that our timestamp conforms to the proper format."""
    error = False

    length = len(string)
    if length < 8 or length > 12:
        error = True

    semicolon_count = string.count(":")
    if semicolon_count != 2:
        error = True

    if not error:
        return string
    else:
        msg = "%r is not in the hh:mm:ss[.xxx] format." % string
        error_out("s", "start", msg)

def duration(string):
    """Test that our duration conforms to the proper format."""
    error = False

    length = len(string)
    if length > 12:
        error = True

    semicolon_count = string.count(":")
    if semicolon_count > 0:
        if semicolon_count != 2:
            error = True

    if not error:
        return string
    else:
        msg = "%r is not in the hh:mm:ss[.xxx] format." % string
        error_out("s", "start", msg)

def crf(string):
    """Test that the quality number is within our range."""
    quality = int(string)
    if quality >= 0 and quality <= 63:
        return quality
    else:
        msg = "%r is out of the quality range. (0-63)" % string
        error_out("q", "quality", msg)

def filesize(string):
    """Test if the filesize argument has a proper suffix."""
    number = string[:-1]
    suffix = string[-1].upper()
    if suffix == "K" or suffix == "M":
        return number + suffix
    else:
        msg = "%r does not include a K or M suffix." % string
        error_out("b/-l", "bitrate/--limit", msg)

def subtitle(string):
    """Test if our subtitle file exists."""
    if string == "0":
        return string
    else:
        exists = os.path.isfile(string)
        if exists:
            return string
        else:
            msg = "%r not found." % string
            error_out("e", "embed", msg)

def get_args():
    """Obtain the arguments entered for our program on the command line."""
    # Define all of our arguments and their help messages
    parser = configargparse.ArgumentParser(add_help=False, prog="htmlgif",
                                           description="A tool to create html5"
                                                       " snippets of videos.",
                                           epilog="For additional help, see"
                                                  " man %(prog)s")

    group0 = parser.add_argument_group("Required Options")
    group0.add_argument("video", #type=file,
                        help="The path to the video file.")

    group1 = parser.add_argument_group("General Options")
    group1.add_argument("-h", "--help", action="help",
                        help="Print this help message.")
    group1.add_argument("-o", "--output", metavar="name",
                        help="The output filename. If omitted, a unix"
                             " timestamp is used.")
    group1.add_argument("-c", "--config", metavar="file", #is_config_file=True,
                        help="The path to a custom config file.")
    group1.add_argument("-v", "--verbose", action="count",
                        help="Use once to show ffmpeg output and twice to make"
                             " %(prog)s verbose also.")
    group1.add_argument("-V", "--version", action="version",
                        version="%(prog)s 1.0.0", help="Print version number.")

    group2 = parser.add_argument_group("Time Options",)
    group2.add_argument("-s", "--start", metavar="time", type=time_stamp,
                        help="Time to start at in hh:mm:ss[.xxx] format."
                             " (Only milliseconds are optional)")
    group2.add_argument("-t", "--to", metavar="dur", type=duration,
                        help="The duration in seconds and milliseconds. A"
                             " timestamp can also be used.")
    group2.add_argument("-D", "--duplicate", action="store_true",
                        help="Copy whole video. (Incompatible with -s/-t)")

    group3 = parser.add_argument_group("Format Options")
    group3.add_argument("-W", "--webm", action="store_true",
                        help="Create a webM. (Default)")
    group3.add_argument("-m", "--mp4", action="store_true",
                        help="Create an MP4 instead of webM. Quality works on"
                             " a different scale.")
    group3.add_argument("-S", "--sound", action="store_true",
                        help="Include sound.")

    group4 = parser.add_argument_group("Quality Options", "Use -l if you know"
                                       " size limit, else -q with -b")
    group4.add_argument("-q", "--quality", metavar="crf", type=crf,
                        help="Quality threshold. Lower is better. Defaults:"
                             " 10 for webm (4-63) and 23 for mp4 (0-51).")
    group4.add_argument("-b", "--bitrate", metavar="rate", type=filesize,
                        help="Bitrate to use. Must include K or M suffix."
                             " (Default: 750K)")
    group4.add_argument("-l", "--limit", metavar="size", type=filesize,
                        help="Set quality and bitrate to fit in the maximum"
                             " specified size. Must include K or M suffix."
                             " 2-pass.")
    group4.add_argument("-p", "--twopass", action="store_true",
                        help="Run two passes.")

    group5 = parser.add_argument_group("Filters")
    group5.add_argument("-w", "--width", metavar="num", type=int,
                        help="The width of the output file. Enter 0 for no"
                             " scaling. (Default: 640)")
    group5.add_argument("-e", "--embed", metavar="subs", type=subtitle,
                        help="Embed subtitles. Enter 0 to use internal subs.")
    group5.add_argument("-F", "--filters", metavar="string",
                        help="Extra filters to pass to ffmpeg's -vf option"
                             " with commas separating them.")


    # Display a help message if the program is run without arguments
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    # Get arguments and print a friendly error for missing files
    try:
        args = parser.parse_args()
    except IOError:
        print "error: positional argument video: file does not exist."
        sys.exit(1)

    if (args.start is None or args.to is None) and not args.duplicate:
        msg = "Start or end time missing."
        error_out("s/-t", "start/--to", msg)

    if (args.bitrate is None or args.quality is None) and args.limit is None:
        msg = "Bitrate and quality missing"
        error_out("b/-q", "bitrate/--quality", msg)

    # Check for conflicting options
    if args.mp4:
        if args.webm:
            msg = "Conflicting use with -W."
            error_out("m", "mp4", msg)

    if args.duplicate:
        if args.start is not None or args.to is not None:
            msg = "Conflicting use with -s/-t."
            error_out("D", "duplicate", msg)

    if args.limit is not None:
        if args.quality is not None or args.bitrate is not None:
            msg = "Conflicting use with -q/-b."
            error_out("l", "limit", msg)

        if not args.twopass:
            args.twopass = True

    return args

def get_filters(args):
    """Chain together filters for the -vf portion of our command"""
    filterlist = [args.width, args.embed, args.filters]
    filter_cmd = ""

    for filters in filterlist:
        if filters is not None:
            filter_cmd = filter_cmd + ","

    # Remove trailing comma
    filter_cmd = filter_cmd[:-1]

    return filter_cmd

def timestamp_to_ms(timestamp):
    """Break up a timestamp and convert it to milliseconds"""
    # "hh" : "mm" : "ss.xxx"
    hms = timestamp.split(":")
    # Convert seconds and milliseconds to a list
    hms[2] = hms[2].split(".")
    # If there aren't any milliseconds
    if len(hms[2]) != 2:
        hms[2][1] = 0

    millisec = (hms[0] * 3600 + hms[1] * 60 + hms[2][0]) * 1000 + hms[2][1]

    print "Returning: ", millisec
    return millisec

def calculate_duration(args):
    """Calculate the duration of our video if the -t arg is a timestamp"""
    # Calculate the difference between the two timestamps converted to ms
    beginning = timestamp_to_ms(args.start)
    end = timestamp_to_ms(args.to)

    difference_ms = end - beginning
    difference_s = float(difference_ms) / 1000

    return str(difference_s)

def calculate_bitrate(args):
    """Calculate the optimal bitrate for our size limit"""
    limit = args.limit
    size_limit = float(limit[:-1])
    # Convert megabyte to kilobyte
    if limit.endswith("M"):
        size_limit *= 1024

    vid_duration = float(args.to)

    new_limit = size_limit / vid_duration * 8
    new_limit = str(round(new_limit, 2)) + "K"
    return new_limit

def get_full_duration(ffprobe, video_path):
    """Run a command to get the duration of our input video"""
    cmd = "%s -i %s" % (ffprobe, video_path)
    cmd += "-loglevel error -show_entries format=duration"
    cmd_list = cmd.split()

    metadata = subprocess.check_output(cmd_list)
    # [FORMAT]\nduration=s.xxxxx\n[/FORMAT]\n
    duration_line = metadata.splitlines()[1]
    # duration=s.xxxxx
    metadata_duration = duration_line.split("=")[1]

    return metadata_duration

def build_cmd(args):
    """Build our ffmpeg command from our arguments"""
    cmd = ""

    if os.name == "nt":
        ffmpeg_bin = "ffmpeg.exe"
        ffprobe_bin = "ffprobe.exe"
    else:
        ffmpeg_bin = "ffmpeg"
        ffprobe_bin = "ffprobe"
    cmd += ffmpeg_bin

    cmd += " -y"
    cmd += " -threads 0"
    cmd += " -hide_banner"

    # Set the proper verbosity for ffmpeg. Default only shows errors.
    if args.verbose is None:
        verbosity = "error"
    else:
        verbosity = "info"
    cmd += " -loglevel %s" % verbosity

    seek_cmd = " -ss %s" % args.start
    input_cmd = " -i '%s'" % args.video
    if args.embed is None:
        # fast seek if not embedding subs
        cmd = cmd + seek_cmd + input_cmd
    else:
        cmd = cmd + input_cmd + seek_cmd

    # If copying, get video duration
    if args.duplicate:
        args.to = get_full_duration(ffprobe_bin, args.video)

    # If duration is a timestamp, convert to a duration
    semicolons = args.to.count(":")
    if semicolons > 0:
        args.to = calculate_duration(args)
    cmd += " -t %s" % args.to

    if args.mp4:
        codec = "libx264"
        extension = ".mp4"
    else:
        codec = "libvpx"
        extension = ".webm"
    cmd += " -c:v %s" % codec

    if args.limit is None:
        cmd += " -crf %s" % args.quality
        cmd += " -b:v %s" % args.bitrate
    else:
        bitrate = calculate_bitrate(args)
        # cmd += " -crf 0"
        cmd += " -b:v %s" % bitrate

    filters = get_filters(args)
    if filters != "":
        cmd += " -vf %s" % filters

    # Exclude sound
    if not args.sound:
        cmd += " -an"

    # Output File
    if args.output is None:
        filename = str(int(time.time())) + extension
    else:
        filename = args.output
    cmd += " '%s'" % filename

    print cmd
    return cmd

def run_cmd(cmd, passes):
    """Takes the ffmpeg command list and runs it"""
    # Split the quoted filenames first, then concat the rest of the list
    cmds = cmd.split("'")
    cmd_list = cmds[0].split() + [cmds[1]] + cmds[2].split() + [cmds[3]]

    exit_code = subprocess.call(cmd_list)

    if exit_code != 0:
        print "ffmpeg exited with a nonzero error code(%d)" % exit_code
        exit(1)

def main():
    """Get options from config file and the command line. Then use them to
    create and execute our ffmpeg command.
    """
    arguments = get_args()

    # for key in var(arguments):
    #     print key, ":", arguments[key]
    # print "\n\n"

    command = build_cmd(arguments)

    if arguments.twopass:
        passes = 2
    else:
        passes = 1

    # run_cmd(command, passes)
    sys.exit(0)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        sys.stderr.write("User sent keyboard interrupt. Exiting...")
        exit(1)

# prepend the zeroes in timestamp

# try variable bitrate only for -l (-b:v) and leave out the -crf
# B:V (max bitrate for crf) might have no effect for mp4's. test it out, might
#  have to use presets

# sub-commands to concat/cut/other??

# detect what flags ffmpeg was compiled with to remove unused options
# (ffmpeg -hide_banner -buildconf)


# https://trac.ffmpeg.org/wiki/Encode/VP8
# https://trac.ffmpeg.org/wiki/Encode/H.264
# constant quality mode is reccomended for libpvx
# -q uses Variable bitrate, -l uses constant quality
# This version of ffmpeg has nonfree parts compiled in. Therefore it is not
# legally redistributable.
